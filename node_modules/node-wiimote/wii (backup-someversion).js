var HID = require('node-hid'),
  colors = require('colors'),
  events = require('events'),
  util = require('util'),
	os = require('os');

var dead = 10

var bindings = [
	{
		prettyName: "D-Pad Left",
		handlerType: "button_left",
		byteBlock: 1,
		bit: 0x01
	},
	{
		prettyName: "D-Pad Right",
		handlerType: "button_right",
		byteBlock: 1,
		bit: 0x02
	},
	{
		prettyName: "D-Pad Down",
		handlerType: "button_down",
		byteBlock: 1,
		bit: 0x04
	},
	{
		prettyName: "D-Pad Up",
		handlerType: "button_up",
		byteBlock: 1,
		bit: 0x08
	},
	{
		prettyName: "Plus",
		handlerType: "button_plus",
		byteBlock: 1,
		bit: 0x10
	},
	{
		prettyName: "Two",
		handlerType: "button_2",
		byteBlock: 2,
		bit: 0x01
	},
	{
		prettyName: "One",
		handlerType: "button_1",
		byteBlock: 2,
		bit: 0x02
	},
	{
		prettyName: "B",
		handlerType: "button_b",
		byteBlock: 2,
		bit: 0x04
	},
	{
		prettyName: "A",
		handlerType: "button_a",
		byteBlock: 2,
		bit: 0x08
	},
	{
		prettyName: "Minus",
		handlerType: "button_minus",
		byteBlock: 2,
		bit: 0x10
	},
	{
		prettyName: "Home",
		handlerType: "button_home",
		byteBlock: 2,
		bit: 0x80
	},
];

function wiiController() {
	this.last = {buttons: {}}; // Setup shit I need
	
	this.vibrating = false;
	this.lightsState = 0;
	
	this.eventListeners = [];
	
	var u = this; 
	
	// NOT MY CODE

  var devices = HID.devices(); // Ok kinda get this

	devices.forEach((function(d) { // I have no fucking idea what this does. But it's good cause I need it :)
		if(typeof d === 'object' && d.product !== undefined) {
			if (d.product.toLowerCase().indexOf('rvl-cnt') !== -1) {
				u.hid = new HID.HID(d.path)
			}
		}
	}).bind(this)) 

	try{
		// Fire event listener.
		this.hid.on("data", function(e) {
			// Detect Message type & Values
			
			// Ensure message type == 0x30
			if (e[0] == 0x30) {
				// Brace
				var found = {buttons: {}};
				var byteblockcopy = [0x30, e[1], e[2]];
				var eventsToRun = {};
				
				// Check for bits, largest to smallest
				for (var i = bindings.length - 1; i >= 0; i--) {
					var work = bindings[i];
					if (byteblockcopy[work.byteBlock] - work.bit >= 0) {
						byteblockcopy[work.byteBlock] -= work.bit;
						found.buttons[work.handlerType] = true;
					} else {
						found.buttons[work.handlerType] = false;
					}
				}
				
				// Now I should have some found values yay;
				
				var foundKeys = Object.keys(found.buttons);// BC IM LAZY
				var lastKeys = Object.keys(u.last.buttons); 
				
				if (foundKeys.length == lastKeys.length) { // Double check last and found have same length
					for (var i = 0; i < foundKeys.length; i++) { // Using foundkeys all the way now to ensure that no differences in key order.
						if (found.buttons[foundKeys[i]] == true && u.last.buttons[foundKeys[i]] == false) { // If pressed now and not before,
							eventsToRun[foundKeys[i]] = "pressed"; // Saving that pressed event is correct
						} else if (found.buttons[foundKeys[i]] == false && u.last.buttons[foundKeys[i]] == true) { // If released as an else if because fuck you and fuck me, that's why
							eventsToRun[foundKeys[i]] = "released"; // Saving that released event is correct
						} 
					}
				} else if (lastKeys.length == 0) { // If last has not been set we have fresh
					for (var i = 0; i < foundKeys.length; i++) { // Modified version of above
						if (found.buttons[foundKeys[i]] == true) { // If pressed
							eventsToRun[foundKeys[i]] = "pressed";
						}
					}
				} else { // We fucked
					console.log( 'Error: '.red, 'We\'re fucked' );
				}
				
				// Now to fucking enumerate the events.
				// BTW: Assuming there will likely only be one change per call of this function.
				
				var eventKeysYawn = Object.keys(eventsToRun);
				
				for (var i = 0; i < eventKeysYawn.length; i++) {
					var sevn = eventKeysYawn[i];
					for (var j = 0; j < u.eventListeners.length; j++) {
						if (u.eventListeners[j].type == sevn && u.eventListeners[j].action == eventsToRun[sevn]) {
							u.eventListeners[j].callback();
						}
					}
				}
				
				// DEBUGGING GOD MODE YEEEEEEEEEEET
				// console.log(eventsToRun);
				
				u.last = found;
			}
		});
	}
	catch ( ex ){
		console.log( 'Error: '.red, 'Wii controller could not be found.' );
	}
}

wiiController.prototype.on = function(type, action, callback) { // The most important function. Why? Because this makes sure nothing else gets shafted
	var typeSHIIIT = true;
	for (var i = 0; i < bindings.length; i++) {
		if (type == bindings[i].handlerType) {
			typeSHIIIT = false;
			break;
		}
	}
	
	if (typeSHIIIT) {
		console.log( 'Error: '.red, 'Invalid event type specified (see docs)' );
		return;
	}
	
	if (action !== "pressed" && action !== "released") {
		console.log( 'Error: '.red, 'Invalid action type specified (pressed or released' );
		return;
	}
	
	this.eventListeners.push({
		type: type,
		action: action,
		callback: callback
	});
};



// THE EASY SHIT OHHHHHHHHHHHHHHHH
wiiController.prototype.setLights = function(lx1, lx2, lx3, lx4) {
	// Validation
	if (typeof lx1 !== "boolean" || typeof lx2 !== "boolean" || typeof lx3 !== "boolean" || typeof lx4 !== "boolean") {
		console.log( 'Error: '.red, 'all values should be true or false (total 4 args required)' );
		return;
	} else {
		// Calculate out the value
		var total = 0;
		if (lx1) {
			total += 16;
		}
		if (lx2) {
			total += 32;
		}
		if (lx3) {
			total +=64;
		}
		if (lx4) {
			total += 128;
		}
		this.lightsState = total; // Store this number for later
		if (this.vibrating) { // Vibration is in same packet, so ensure same
			total += 1;
		}
		// Send command
		this.hid.write([0x11, total]);
	}
};

wiiController.prototype.vibration = function(on) {
	// Validation
	if (typeof on !== "boolean") {
		console.log( 'Error: '.red, 'argument 1 should be true or false (total 1 arg required)' );
		return;
	} else {
		// Load current lights state
		var total = this.lightsState;
		if (on) { // Add to lights state
			total += 1;
		}
		
		this.vibrating = on; // Remember current vibration
		
		// Send command
		this.hid.write([0x11, total]);
	}
};

module.exports = wiiController